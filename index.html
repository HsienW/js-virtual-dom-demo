<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Virtual Dom Simulation</title>
</head>
<body>
<script>
    // 一個 Virtual Dom 下的 Node 展開後, 類似下面這個 element object
    // let element = {
    //     tagName: 'ul',  // Node 標籤名
    //     props: {  // DOM 的屬性，用一個對象存儲鍵值對
    //         id: 'list'
    //     },
    //     children: [  // Node 的子節點
    //         {tagName: 'li', props: {class: 'item'}, children: ["Item 1"]},
    //         {tagName: 'li', props: {class: 'item'}, children: ["Item 2"]},
    //         {tagName: 'li', props: {class: 'item'}, children: ["Item 3"]},
    //     ]
    // }

    const Element = function (tagName, props, children) {
        this.tagName = tagName
        this.props = props
        this.children = children
    }

    Element.prototype.render = function () {
        let element = document.createElement(this.tagName) // 依照 tagName 創建
        let props = this.props

        for (let propName in props) { // 設定 DOM 的 Node 屬性
            let propValue = props[propName]
            element.setAttribute(propName, propValue)
        }

        let children = this.children || []

        children.forEach((child) => {
            let childElement = (child instanceof Element)
                ? child.render() // 如果子節點也是虛擬 DOM, 遞迴創建 DOM 結點
                : document.createTextNode(child) // 如果字串, 只創建文字結點
            element.appendChild(childElement)
        })

        return element;
    }

    const ulNode = new Element('ul', {id: 'list'}, [
        new Element('li', {class: 'item'}, ['Item 1']),
        new Element('li', {class: 'item'}, ['Item 2']),
        new Element('li', {class: 'item'}, ['Item 3'])
    ]);

    console.log(ulNode);

    const ulRootDom = ulNode.render();
    document.body.appendChild(ulRootDom);

    /* === Diff 算法 === */

    // 對新舊兩棵 tree 的子節點 做檢查 (深度優先)
    function childrenDiffCheck (oldChildren, newChildren, index, patches) {
        let leftNode = null; // left Node 為深度優先, 是從左邊開始往下檢查
        let currentNodeIndex = index; //0
        oldChildren.forEach((child, index) => {
            // 從 newChildren 中取出對應要比較的 New Node
            let newChild = newChildren[index];
            // 計算 Node 的標誌
            currentNodeIndex = (leftNode && leftNode.count)
                ? currentNodeIndex + leftNode.count + 1 // 若 index & count 屬性為空 => 0 + null + 1 = 1
                : currentNodeIndex + 1 // // 若 index 為 1 => 1 + 1 = 2 以此類推
            differentCheck(child, newChild, currentNodeIndex, patches) // 遞迴, 且深度優先的歷遍子節點
            leftNode = child
        })
    }

    // 對新舊兩棵 tree 做深度優先的歷遍檢查
    function differentCheck (oldNode, newNode, index, patches) {
        // 對比新舊 Node 的不同處, 且記錄下來
        patches[index] = [...patches];
        childrenDiffCheck(oldNode.children, newNode.children, index, patches)
    }

    function diff (oldTree, newTree) {
        let index = 0 // 當前 Node 的 Index
        let patches = {} // 紀錄每個 Node Object 的差異

        differentCheck(oldTree, newTree, index, patches)
        return patches
    }

</script>
</body>
</html>
