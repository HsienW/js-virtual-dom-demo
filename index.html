<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Virtual Dom Simulation</title>
</head>
<body>
<script>
    // 一個 Virtual Dom 下的 Node 展開後, 類似下面這個 element object
    let element = {
        tagName: 'ul',  // Node 標籤名
        props: {  // DOM 的屬性，用一個對象存儲鍵值對
            id: 'list'
        },
        children: [  // Node 的子節點
            {tagName: 'li', props: {class: 'item'}, children: ["Item 1"]},
            {tagName: 'li', props: {class: 'item'}, children: ["Item 2"]},
            {tagName: 'li', props: {class: 'item'}, children: ["Item 3"]},
        ]
    }

    /* === Create Element === */

    const Element = function (tagName, props, children) {
        this.tagName = tagName;
        this.props = props;
        this.children = children;
    }

    Element.prototype.render = function () {
        let element = document.createElement(this.tagName); // 依照 tagName 創建
        let props = this.props;

        for (let propName in props) { // 設定 DOM 的 Node 屬性
            let propValue = props[propName];
            element.setAttribute(propName, propValue);
        }

        let children = this.children || [];

        children.forEach((child) => {
            let childElement = (child instanceof Element)
                ? child.render() // 如果子節點也是虛擬 DOM, 遞迴創建 DOM 結點
                : document.createTextNode(child) // 如果字串, 只創建文字結點
            element.appendChild(childElement)
        });

        return element;
    }

    /* === Diff 算法 === */

    // 對新舊兩棵 tree 的子節點 做檢查 (深度優先)
    function childrenDiffCheck(oldChildren, newChildren, index, patches) {
        // left Node 為深度優先, 是從左邊開始往下檢查
        let leftNode = null;

        // 最初始為 0, 因為從 tree 最上層開始
        let currentNodeIndex = index;

        // 從舊 tree 的 Children 下手
        oldChildren.forEach((child, index) => {
            // 從 newChildren 中取出對應要比較的 New Node
            let newChildNode = newChildren[index];

            // 計算 Node 的標誌
            currentNodeIndex = (leftNode && leftNode.count)
                // 若 index & count 屬性為空 => 0 + null + 1 = 1
                ? currentNodeIndex + leftNode.count + 1

                // 若 index 為 1 => 1 + 1 = 2 以此類推
                : currentNodeIndex + 1
            diffCheck(child, newChildNode, currentNodeIndex, patches) // 遞迴, 且深度優先的歷遍子節點
            leftNode = child
        })
    }

    // 對新舊兩棵 tree 做深度優先的歷遍檢查
    function diffCheck(oldNode, newNode, index, patches) {
        // 對比新舊 Node 的不同處, 且記錄下來
        patches[index] = [...patches];
        childrenDiffCheck(oldNode.children, newNode.children, index, patches)
    }

    const REPLACE = 0 // 替換掉原來的 node, 例如把原本的 div 換成了 ul
    const REORDER = 1 // 移動、刪除、新增子節點, 例如原本有一個 ul, 把它跟其他同層的 node 順序互換
    const PROPS = 2 // 修改了節點的 props
    const TEXT = 3 // 文字類型的 node 修改, 文字內容可能會改變, 例如本來的一個 'test' 改成 'test2'

    /* === Complete Diff === */

    function diffCheckProps(oldNode, newNode) {
        let count = 0;
        let oldProps = oldNode.props;
        let newProps = newNode.props;
        let key, value;
        let propsPatches = {};

        // 先用 oldProps 取出來 props 一個個比對
        for (key in oldProps) {
            value = oldProps[key];
            if (newProps[key] !== value) {
                // 若有差異就 count +1
                count++;
                // 並把 newProps 的, 記錄到 propsPatches 上
                propsPatches[key] = newProps[key];
            }
        }

        // 檢查 newProps, 因為有可能是全新的 props, old 上沒有
        for (key in newProps) {
            value = newProps[key];

            // 檢查 newProps, 是否有以前 oldProps 沒有的
            if (!oldProps.hasOwnProperty(key)) {
                // 若有就 count +1
                count++;
                // 並把 newProps 的, 記錄到 propsPatches 上
                propsPatches[key] = newProps[key];
            }
        }

        // 如果 count 是 0 就表示新舊兩個 props 都一樣, 回傳 null
        if (count === 0) {
            return null
        }

        // 回傳 propsPatches, 比出差異的 object
        return propsPatches
    }

    function completeDiffCheck(oldNode, newNode, index, patches) {
        let currentPatch = []

        // node 的移除
        if (newNode === null) {
            // 處理重新排序, 真實的 dom 節點將被移除, 所以這邊不用做事
            return;
        }

        // 當 node type 是文字時
        if (oldNode instanceof String && newNode instanceof String) {
            // 如果新舊節點不同, 表示真實 dom 也需刷新, 紀錄進去 Patch
            if (newNode !== oldNode) {
                // type 是 TEXT 類型
                currentPatch.push({type: TEXT, content: newNode})
            }
            return;
        }

        // 當 node 不是文字, 且新舊節點的都相同時, 接著檢查新舊節點的 props and children
        if (oldNode.tagName === newNode.tagName && oldNode.key === newNode.key) {
            // 檢查 props
            let propsPatches = diffCheckProps(oldNode, newNode);

            // 如果檢查 props 後, 發現新舊兩個有差異
            if (propsPatches) {
                // props 有差異, 表示真實 dom 也需刷新, 紀錄進去 Patch
                // type 是 PROPS
                currentPatch.push({type: PROPS, props: propsPatches});
            }
            // 檢查 children. 如果新節點的 children 帶有 ignore 屬性, 就不做 diff check
            if (!isIgnoreChildren(newNode)) {
                // todo change to "childrenDiffCheck"
                diffChildren(oldNode.children, newNode.children, index, patches, currentPatch);
            }
            // Nodes are not the same, replace the old node with new node
        } else {
            currentPatch.push({type: patch.REPLACE, node: newNode})
        }

        if (currentPatch.length) {
            patches[index] = currentPatch
        }
    }

    function isIgnoreChildren (node) {
        return (node.props && node.props.hasOwnProperty('ignore'))
    }

    function diff(oldTree, newTree) {
        let index = 0 // 當前 Node 的 Index
        let patches = {} // 紀錄每個 Node Object 的差異

        diffCheck(oldTree, newTree, index, patches)
        return patches
    }


    /* === Patch to DOM === */

    function patch(node, patches) {
        let checker = {index: 0}
        patchCheck(node, checker, patches)
    }

    function patchCheck(node, checker, patches) {
        // 從 patches 取出與當前節點的差異
        let currentPatches = patches[checker.index]

        // 若被 Check 的節點, 沒有子節點的話, 將長度歸零, 表示深度到底了
        let length = node.childNodes ? node.childNodes.length : 0;

        // 開始深度歷遍子節點
        for (let i = 0; i < length; i++) {
            let child = node.childNodes[i]
            checker.index++

            // 使用遞迴的方式做 Check
            patchCheck(child, checker, patches)
        }

        // 對當前已經抓出差異點的 node 做 DOM 的改變
        if (currentPatches) {
            applyPatches(node, currentPatches)
        }
    }

    function applyPatches(node, currentPatches) {
        currentPatches.forEach((currentPatch) => {
            switch (currentPatch.type) {
                case REPLACE:
                    node.parentNode.replaceChild(currentPatch.node.render(), node)
                    break
                case REORDER:
                    reorderChildren(node, currentPatch.moves)
                    break
                case PROPS:
                    setProps(node, currentPatch.props)
                    break
                case TEXT:
                    node.textContent = currentPatch.content
                    break
                default:
                    throw new Error('Unknown patch type ' + currentPatch.type)
            }
        })
    }


    // const ulNode = new Element('ul', {id: 'list'}, [
    //     new Element('li', {class: 'item'}, ['Item 1']),
    //     new Element('li', {class: 'item'}, ['Item 2']),
    //     new Element('li', {class: 'item'}, ['Item 3'])
    // ]);
    //
    // console.log(ulNode);
    //
    // const ulRootDom = ulNode.render();
    // document.body.appendChild(ulRootDom);

    //  const createElement = function(type, props, children) {
    //      // 直接 return 一個 object, 用來產生 Virtual Dom 下的 node 結構
    //      // 把 children 掛入 props, 以便後續能用 this.props.children 拿取子 node
    //      return {
    //          type,
    //          props: {
    //              ...props,
    //              ...children
    //          }
    //      }
    // }
    // const render = function (vDom, container) {
    //      // 用來存放 vDom 的 object
    //     let dom;
    //
    //     // 先檢查當前要 render 的 vDom 是 object or string
    //     if(typeof vDom !== 'object') {
    //         // 是 string 的話, 創建 TextNode
    //         dom = document.createTextNode(vDom)
    //     } else {
    //         // 是 object 的話, 創建 Element
    //         dom = document.createElement(vDom.type);
    //     }
    // }

</script>
</body>
</html>
