<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Virtual Dom Simulation</title>
</head>
<body>
<script>
    // 一個 Virtual Dom 下的 Node 展開後, 類似下面這個 element object
    let element = {
        tagName: 'ul',  // Node 標籤名
        props: {  // DOM 的屬性，用一個對象存儲鍵值對
            id: 'list'
        },
        children: [  // Node 的子節點
            {tagName: 'li', props: {class: 'item'}, children: ["Item 1"]},
            {tagName: 'li', props: {class: 'item'}, children: ["Item 2"]},
            {tagName: 'li', props: {class: 'item'}, children: ["Item 3"]},
        ]
    }

    // // 對新舊兩棵 tree 做深度優先的歷遍檢查
    // function diffCheck(oldNode, newNode, index, patches) {
    //     // 對比新舊 Node 的不同處, 且記錄下來
    //     patches[index] = [...patches];
    //     childrenDiffCheck(oldNode.children, newNode.children, index, patches)
    // }

    const REPLACE = 0 // 替換掉原來的 node, 例如把原本的 div 換成了 ul
    const REORDER = 1 // 移動、刪除、新增子節點, 例如原本有一個 ul, 把它跟其他同層的 node 順序互換
    const PROPS = 2 // 修改了節點的 props
    const TEXT = 3 // 文字類型的 node 修改, 文字內容可能會改變, 例如本來的一個 'test' 改成 'test2'

    /* === Patch to DOM === */

    function patch(node, patches) {
        let checker = {index: 0}
        patchCheck(node, checker, patches)
    }

    function patchCheck(node, checker, patches) {
        // 從 patches 取出與當前節點的差異
        let currentPatches = patches[checker.index]

        // 若被 Check 的節點, 沒有子節點的話, 將長度歸零, 表示深度到底了
        let length = node.childNodes ? node.childNodes.length : 0;

        // 開始深度歷遍子節點
        for (let i = 0; i < length; i++) {
            let child = node.childNodes[i]
            checker.index++

            // 使用遞迴的方式做 Check
            patchCheck(child, checker, patches)
        }

        // 對當前已經抓出差異點的 node 做 DOM 的改變
        if (currentPatches) {
            applyPatches(node, currentPatches)
        }
    }

    function applyPatches(node, currentPatches) {
        currentPatches.forEach((currentPatch) => {
            switch (currentPatch.type) {
                case REPLACE:
                    node.parentNode.replaceChild(currentPatch.node.render(), node)
                    break
                case REORDER:
                    reorderChildren(node, currentPatch.moves)
                    break
                case PROPS:
                    setProps(node, currentPatch.props)
                    break
                case TEXT:
                    node.textContent = currentPatch.content
                    break
                default:
                    throw new Error('Unknown patch type ' + currentPatch.type)
            }
        })
    }


    // const ulNode = new Element('ul', {id: 'list'}, [
    //     new Element('li', {class: 'item'}, ['Item 1']),
    //     new Element('li', {class: 'item'}, ['Item 2']),
    //     new Element('li', {class: 'item'}, ['Item 3'])
    // ]);
    //
    // console.log(ulNode);
    //
    // const ulRootDom = ulNode.render();
    // document.body.appendChild(ulRootDom);

    //  const createElement = function(type, props, children) {
    //      // 直接 return 一個 object, 用來產生 Virtual Dom 下的 node 結構
    //      // 把 children 掛入 props, 以便後續能用 this.props.children 拿取子 node
    //      return {
    //          type,
    //          props: {
    //              ...props,
    //              ...children
    //          }
    //      }
    // }
    // const render = function (vDom, container) {
    //      // 用來存放 vDom 的 object
    //     let dom;
    //
    //     // 先檢查當前要 render 的 vDom 是 object or string
    //     if(typeof vDom !== 'object') {
    //         // 是 string 的話, 創建 TextNode
    //         dom = document.createTextNode(vDom)
    //     } else {
    //         // 是 object 的話, 創建 Element
    //         dom = document.createElement(vDom.type);
    //     }
    // }

</script>
</body>
</html>
